# QuantumState

**Autonomous SRE agent swarm for production incident detection, investigation, and remediation.**

---

## What is this?

QuantumState is an AI agent system that watches over a production infrastructure and handles incidents automatically — from the moment an anomaly is detected to the moment a fix is verified and logged.

Instead of an on-call engineer getting paged at 3am, spending 45 minutes correlating dashboards, Slack messages, and deployment logs to figure out what broke and why — QuantumState does it in under 4 minutes.

---

## The problem it solves

Modern software runs as many small services (microservices). When something goes wrong — a memory leak, a bad deployment, a cache going offline — the failure rarely announces itself clearly. An engineer has to:

1. Notice the error rate is climbing (if they're watching)
2. Check which service is affected
3. Correlate the timing with recent deployments
4. Search through thousands of log lines for the root cause
5. Decide on a fix, get approval, execute it
6. Verify it worked

This takes 30–90 minutes on average. QuantumState compresses it to under 4 minutes by automating every step with a chain of specialised AI agents.

---

## How it works

Three agents work in sequence, each handed the output of the previous:

```
Elasticsearch (metrics + logs)
        │
        ▼
┌───────────────────┐
│    Cassandra      │  Detection agent
│                   │  Runs ES|QL queries every few minutes.
│  "I see memory    │  Compares current metrics to 24h baseline.
│  climbing on      │  Calculates time-to-failure.
│  payment-service" │  Confidence: 94%
└────────┬──────────┘
         │
         ▼
┌───────────────────┐
│  Archaeologist    │  Investigation agent
│                   │  Searches logs for errors in the same time window.
│  "Deploy v2.1.0   │  Finds similar past incidents.
│  introduced a     │  Correlates deploy events with metric changes.
│  connection pool  │  Builds an evidence chain.
│  leak"            │
└────────┬──────────┘
         │
         ▼
┌───────────────────┐
│     Surgeon       │  Action agent
│                   │  Triggers an Elastic Workflow to execute the fix.
│  "Rolled back to  │  Verifies the fix worked (error rate back to normal).
│  v2.0.9. Memory   │  Writes a full audit record.
│  stabilised."     │
└───────────────────┘
        │
        ▼
incidents-quantumstate (resolved incident record)
agent-decisions-quantumstate (full audit trail)
```

The chain is orchestrated by an **Elastic Workflow** that calls each agent as a step using the native `ai.agent` step type. No custom Python orchestration — it's all native Elastic tooling.

---

## The fictional environment

QuantumState monitors the backend of a fictional **e-commerce platform** — think the infrastructure behind something like Shopify or Amazon. When a customer shops, every click touches multiple services in sequence:

```
Customer browses → logs in → adds to cart → checks out → payment charged → stock decremented
                    │                           │               │                  │
                auth-service          checkout-service   payment-service   inventory-service
```

| Service | Role | Why it matters |
|---|---|---|
| **payment-service** | Processes credit card charges and refunds | Every minute it's down is direct lost revenue |
| **checkout-service** | Handles cart → order placement flow | A bug here breaks the entire purchase funnel |
| **auth-service** | Authenticates users via JWT + Redis session cache | Every other service depends on it — if Redis goes down, everything slows |
| **inventory-service** | Tracks stock levels across EU warehouse | Silent failures lead to overselling and fulfilment errors |

This is a deliberately recognisable stack — judges immediately understand what each service does and why an outage is costly. The MTTR story lands harder when the system being fixed is one everyone has used.

All data is synthetic — generated by Python scripts that produce realistic metrics (memory, CPU, error rates, latency) and application logs.

---

## Agents

All three agents are built and tested in Elastic Agent Builder.

### Cassandra — Detection
**ID:** `cassandra-detection-agent`

Runs ES|QL queries against `metrics-quantumstate`, compares current readings to the 24h baseline, and calculates time to failure for degrading services.

| Tool | What it does |
|---|---|
| `detect_memory_leak` | Finds services where memory > 20% above baseline |
| `detect_error_spike` | Finds services where error rate > 3/min |
| `calculate_time_to_failure` | Estimates minutes until 90% memory threshold |

### Archaeologist — Investigation
**ID:** `archaeologist-investigation-agent`

Given a service and anomaly type from Cassandra, searches logs, checks for recent deployments, and matches against historical incidents to determine root cause.

| Tool | What it does |
|---|---|
| `search_error_logs` | Returns ERROR/CRITICAL logs for a service in last 30 min |
| `correlate_deployments` | Searches for deploy events in last 2 hours |
| `find_similar_incidents` | Queries historical incidents for matching anomaly type |

### Surgeon — Remediation
**ID:** `surgeon-action-agent`

Takes the Archaeologist's root cause, executes the fix, verifies recovery against metric thresholds, and logs MTTR and lessons learned.

| Tool | What it does |
|---|---|
| `log_remediation_action` | Reads audit trail for the service |
| `verify_resolution` | Checks memory/error rate/latency against healthy thresholds |
| `get_recent_anomaly_metrics` | Full metric summary (avg/max/min) over last hour |

---

## Tech stack

| Layer | Technology |
|---|---|
| Agent runtime | Elastic Agent Builder |
| Agent tools | ES\|QL (9 custom parameterised queries across 3 agents) |
| Orchestration | Elastic Workflows (`ai.agent` steps) |
| Data store | Elasticsearch Serverless |
| Data generation | Python (`ingest/`) |
| Demo control panel | Streamlit (`ingest/qs_console.py`) |
| SRE Console UI | Next.js |

---

## Project structure

```
quantumstate/
├── ingest/
│   ├── qs_console.py       Streamlit control panel — setup, stream, inject, cleanup
│   ├── inject.py           Anomaly scenario injection functions
│   ├── setup.py            Standalone index setup script
│   └── stream.py           Standalone live metric streamer
├── docs/
│   └── data-model.md       Indices, fields, scenarios explained
├── workflows/
│   └── incident-pipeline.yaml  Elastic Workflow — chains Cassandra → Archaeologist → Surgeon
├── implementation/
│   ├── PLAN.md             Full architecture and build plan
│   ├── PHASE_1.md          Data layer — complete
│   ├── PHASE_2.md          Agent Builder — complete
│   └── PHASE_3.md          Workflow orchestrator — complete
├── agent-builder-docs/     Elastic Agent Builder official docs (reference)
├── notes/                  Challenge brief, research, background
└── sample-project/         Reference implementation from hackathon resources
```

---

## Running the demo console

```bash
# Install dependencies
uv sync

# Start the control panel
streamlit run ingest/qs_console.py
```

The console handles everything:
- **Setup tab** — creates Elasticsearch indices and loads 24h of baseline data
- **Stream tab** — starts live metric streaming (30s interval)
- **Inject tab** — triggers one of 3 anomaly scenarios for the agents to detect
- **Health tab** — live service health cards and log viewer
- **Cleanup tab** — removes any non-QuantumState indices from your Elasticsearch cluster

---

## Environment setup

Create a `.env` file in the project root:

```
ELASTIC_CLOUD_ID=your-cloud-id-here
ELASTIC_API_KEY=your-api-key-here
KIBANA_URL=https://your-deployment.kb.us-east-1.aws.elastic.cloud
```

---

## Workflow orchestrator

The `workflows/incident-pipeline.yaml` wires all three agents into a single automated pipeline using Elastic Workflows native `ai.agent` step type.

```yaml
# Simplified view
steps:
  - name: cassandra
    type: ai.agent
    with:
      agent_id: "cassandra-detection-agent"
      message: "Scan all services for anomalies..."

  - name: archaeologist
    type: ai.agent
    with:
      agent_id: "archaeologist-investigation-agent"
      message: "Cassandra found: {{ steps.cassandra.output }} — find root cause..."

  - name: surgeon
    type: ai.agent
    with:
      agent_id: "surgeon-action-agent"
      message: "Root cause: {{ steps.archaeologist.output }} — verify and log resolution..."
```

To run: Kibana → Workflows → `incident-pipeline` → Run manually.

---

## Demo scenarios

| Scenario | Service | Pattern | Root cause |
|---|---|---|---|
| Memory Leak | payment-service | Memory 55% → 89% over 25 min | JVM connection pool not releasing memory |
| Deployment Rollback | checkout-service | Error rate 0.4 → 18/min after deploy | NPE in cart serialisation in v3.5.0 |
| Error Spike | auth-service | Error rate 0.3 → 28/min instantly | Redis session cache went offline |

---

## Hackathon context

**Event:** Elasticsearch Agent Builder Hackathon
**Dates:** January 22 – February 27, 2026
**Prize pool:** $20,000
**Judging criteria:** Multi-step reasoning, tool orchestration, real-world automation, measurable impact

QuantumState targets the **time-series anomaly detection** and **multi-agent** tracks with a concrete, measurable outcome: MTTR reduced from ~47 minutes to ~4 minutes.
