# QuantumState

**Autonomous SRE agent swarm for production incident detection, investigation, and remediation.**

---

## What is this?

QuantumState is an AI agent system that watches over a production infrastructure and handles incidents automatically — from the moment an anomaly is detected to the moment a fix is verified and logged.

Instead of an on-call engineer getting paged at 3am, spending 45 minutes correlating dashboards and logs — QuantumState does it in under 4 minutes.

---

## How it works

Three agents work in sequence, each handed the output of the previous:

```
Elasticsearch (metrics + logs)
        │
        ▼
┌───────────────────┐
│    Cassandra      │  Detection — runs ES|QL queries, compares current
│                   │  metrics to 24h baseline, calculates time-to-failure
└────────┬──────────┘
         │
         ▼
┌───────────────────┐
│  Archaeologist    │  Investigation — searches logs, correlates deploy
│                   │  events, matches against historical incidents
└────────┬──────────┘
         │
         ▼
┌───────────────────┐
│     Surgeon       │  Remediation — verifies recovery against healthy
│                   │  thresholds, writes full incident audit record
└───────────────────┘
        │
        ▼
incidents-quantumstate (resolved incident record)
agent-decisions-quantumstate (full audit trail)
```

The pipeline is orchestrated by a FastAPI backend (`backend/orchestrator.py`) that calls each agent via the Elastic Agent Builder converse API with real-time SSE streaming. A reference Elastic Workflow YAML (`.backup/workflows/incident-pipeline.yaml`) is also included for native `ai.agent` step execution.

---

## The fictional environment

QuantumState monitors the backend of a fictional **e-commerce platform**. When a customer shops, every click touches multiple services:

```
Customer browses → logs in → adds to cart → checks out → payment charged → stock decremented
                    │                           │               │                  │
                auth-service          checkout-service   payment-service   inventory-service
```

All data is synthetic — generated by the Simulation Control panel which creates realistic metrics, logs, and anomaly scenarios in Elasticsearch.

---

## Agents

All three agents are built in Elastic Agent Builder on **Elastic for Observability** (`quantumstate-prod`).

### Cassandra — Detection
**ID:** `cassandra-detection-agent`

| Tool | What it does |
|---|---|
| `detect_memory_leak` | Finds services where memory peaked above 70% in the last 30 min |
| `detect_error_spike` | Finds services where error rate > 3/min |
| `calculate_time_to_failure` | Estimates minutes until 90% memory threshold |

### Archaeologist — Investigation
**ID:** `archaeologist-investigation-agent`

| Tool | What it does |
|---|---|
| `search_error_logs` | Returns ERROR/CRITICAL logs for a service in last 30 min |
| `correlate_deployments` | Searches for deploy events in last 2 hours |
| `find_similar_incidents` | Queries historical incidents for matching anomaly type |

### Surgeon — Remediation
**ID:** `surgeon-action-agent`

| Tool | What it does |
|---|---|
| `log_remediation_action` | Reads recent audit trail for the service |
| `verify_resolution` | Checks memory/error rate/latency against healthy thresholds |
| `get_recent_anomaly_metrics` | Full metric summary (avg/max/min) over last hour |

> Agents analyse data and recommend actions. They do not directly execute infrastructure changes — actual remediation is executed by a human or an automation layer acting on the agent's recommendation.

---

## Tech stack

| Layer | Technology |
|---|---|
| Agent runtime | Elastic Agent Builder (Elastic for Observability) |
| Agent tools | ES\|QL — 9 custom parameterised queries across 3 agents |
| Orchestration | Python FastAPI — SSE streaming via `/api/agent_builder/converse/async` |
| Data store | Elasticsearch Serverless |
| Frontend | React + Vite + TypeScript + shadcn/ui + Tailwind CSS |
| Backend | FastAPI (Python) |

---

## Project structure

```
quantumstate/
├── frontend/                   React + Vite + TypeScript UI
│   └── src/
│       ├── pages/              Index, Console, SimControl
│       └── components/         console/, landing/, ui/
├── backend/                    FastAPI Python backend
│   ├── main.py
│   ├── elastic.py              Shared Elasticsearch client
│   ├── inject.py               Anomaly injection functions
│   ├── orchestrator.py         Agent Builder SSE streaming
│   └── routers/                incidents, health, pipeline, chat, sim
├── docs/
│   └── data-model.md           Index schemas and demo scenarios
├── agents-definition.md        Full reference for recreating agents and tools
├── start.sh                    Starts frontend + backend
└── .env                        Elastic credentials (not committed)
```

---

## Getting started

### Prerequisites

- Python 3.12+ with `uv` or `pip`
- Node.js 18+
- Elastic Cloud deployment with Agent Builder enabled

### Environment

Create `.env` in the project root:

```
ELASTIC_CLOUD_ID=your-cloud-id
ELASTIC_API_KEY=your-api-key
KIBANA_URL=https://your-deployment.kb.us-east-1.aws.elastic.cloud
```

### Run

```bash
# Install Python dependencies
uv sync

# Start everything
./start.sh
```

- **Landing:** http://localhost:8080
- **Console:** http://localhost:8080/console
- **Sim Control:** http://localhost:8080/sim
- **API:** http://localhost:8000

---

## Simulation Control

The `/sim` page replaces the old Streamlit console. It handles the full demo lifecycle:

| Tab | What it does |
|---|---|
| **Setup** | Creates Elasticsearch indices, loads 24h baseline metrics + logs + 4 historical incidents |
| **Stream** | Starts a background thread emitting live metrics every 30s across all 4 services |
| **Inject** | Triggers one of 3 anomaly scenarios — agents detect it on the next pipeline run |
| **Cleanup** | Clear all documents or delete indices entirely |

---

## Demo scenarios

| Scenario | Service | Pattern | Root cause |
|---|---|---|---|
| Memory Leak | payment-service | Memory 55% → 89% over 25 min | JVM connection pool leak |
| Deployment Rollback | checkout-service | Error rate 0.4 → 18/min after deploy | NPE in cart serialisation (v3.5.0) |
| Error Spike | auth-service | Error rate 0.3 → 28/min instantly | Redis session cache went offline |

---

## Pipeline deduplication

The pipeline tracks which services were handled. On each run:
- Cassandra detects all anomalous services
- Any service that already had an incident written in the last 30 minutes is skipped
- Only new services proceed through Archaeologist → Surgeon → incident write

This means you can inject multiple scenarios at different times and each will be handled exactly once.

---

## Hackathon context

**Event:** Elasticsearch Agent Builder Hackathon
**Dates:** January 22 – February 27, 2026
**Prize pool:** $20,000

QuantumState targets the **time-series anomaly detection** and **multi-agent** tracks with a concrete, measurable outcome: MTTR reduced from ~47 minutes to ~4 minutes.
