# QuantumState

**Autonomous SRE agent swarm for production incident detection, investigation, and remediation.**

---

## What is this?

QuantumState is an AI agent system that watches over a production infrastructure and handles incidents automatically — from the moment an anomaly is detected to the moment a fix is verified and logged.

Instead of an on-call engineer getting paged at 3am, spending 45 minutes correlating dashboards, Slack messages, and deployment logs to figure out what broke and why — QuantumState does it in under 4 minutes.

---

## The problem it solves

Modern software runs as many small services (microservices). When something goes wrong — a memory leak, a bad deployment, a cache going offline — the failure rarely announces itself clearly. An engineer has to:

1. Notice the error rate is climbing (if they're watching)
2. Check which service is affected
3. Correlate the timing with recent deployments
4. Search through thousands of log lines for the root cause
5. Decide on a fix, get approval, execute it
6. Verify it worked

This takes 30–90 minutes on average. QuantumState compresses it to under 4 minutes by automating every step with a chain of specialised AI agents.

---

## How it works

Three agents work in sequence, each handed the output of the previous:

```
Elasticsearch (metrics + logs)
        │
        ▼
┌───────────────────┐
│    Cassandra      │  Detection agent
│                   │  Runs ES|QL queries every few minutes.
│  "I see memory    │  Compares current metrics to 24h baseline.
│  climbing on      │  Calculates time-to-failure.
│  payment-service" │  Confidence: 94%
└────────┬──────────┘
         │
         ▼
┌───────────────────┐
│  Archaeologist    │  Investigation agent
│                   │  Searches logs for errors in the same time window.
│  "Deploy v2.1.0   │  Finds similar past incidents.
│  introduced a     │  Correlates deploy events with metric changes.
│  connection pool  │  Builds an evidence chain.
│  leak"            │
└────────┬──────────┘
         │
         ▼
┌───────────────────┐
│     Surgeon       │  Action agent
│                   │  Triggers an Elastic Workflow to execute the fix.
│  "Rolled back to  │  Verifies the fix worked (error rate back to normal).
│  v2.0.9. Memory   │  Writes a full audit record.
│  stabilised."     │
└───────────────────┘
        │
        ▼
incidents-quantumstate (resolved incident record)
agent-decisions-quantumstate (full audit trail)
```

The chain is orchestrated by an **Elastic Workflow** that calls each agent as a step using the native `ai.agent` step type. No custom Python orchestration — it's all native Elastic tooling.

---

## The fictional environment

QuantumState monitors the backend of a fictional **e-commerce platform** — think the infrastructure behind something like Shopify or Amazon. When a customer shops, every click touches multiple services in sequence:

```
Customer browses → logs in → adds to cart → checks out → payment charged → stock decremented
                    │                           │               │                  │
                auth-service          checkout-service   payment-service   inventory-service
```

| Service | Role | Why it matters |
|---|---|---|
| **payment-service** | Processes credit card charges and refunds | Every minute it's down is direct lost revenue |
| **checkout-service** | Handles cart → order placement flow | A bug here breaks the entire purchase funnel |
| **auth-service** | Authenticates users via JWT + Redis session cache | Every other service depends on it — if Redis goes down, everything slows |
| **inventory-service** | Tracks stock levels across EU warehouse | Silent failures lead to overselling and fulfilment errors |

This is a deliberately recognisable stack — judges immediately understand what each service does and why an outage is costly. The MTTR story lands harder when the system being fixed is one everyone has used.

All data is synthetic — generated by Python scripts that produce realistic metrics (memory, CPU, error rates, latency) and application logs.

---

## Tech stack

| Layer | Technology |
|---|---|
| Agent runtime | Elastic Agent Builder |
| Agent tools | ES|QL (custom parameterised queries) |
| Orchestration | Elastic Workflows (`ai.agent` steps) |
| Data store | Elasticsearch Serverless |
| Data generation | Python (`ingest/`) |
| Demo control panel | Streamlit (`ingest/qs_console.py`) |

---

## Project structure

```
quantumstate/
├── ingest/
│   ├── qs_console.py     Streamlit control panel — setup, stream, inject, cleanup
│   ├── inject.py           Anomaly scenario injection functions
│   ├── setup.py            Standalone index setup script
│   └── stream.py           Standalone live metric streamer
├── docs/
│   └── data-model.md       Full explanation of indices, fields, and scenarios
├── implementation/
│   ├── PLAN.md             Architecture and build plan
│   └── PROGRESS.md         What's done, what's next
├── agent-builder-docs/     Elastic Agent Builder official documentation (reference)
├── notes/                  Challenge brief, research, background
└── sample-project/         Reference implementation from hackathon resources
```

---

## Running the demo console

```bash
# Install dependencies
uv sync

# Start the control panel
streamlit run ingest/qs_console.py
```

The console handles everything:
- **Setup tab** — creates Elasticsearch indices and loads 24h of baseline data
- **Stream tab** — starts live metric streaming (30s interval)
- **Inject tab** — triggers one of 3 anomaly scenarios for the agents to detect
- **Health tab** — live service health cards and log viewer
- **Cleanup tab** — removes any non-QuantumState indices from your Elasticsearch cluster

---

## Environment setup

Create a `.env` file in the project root:

```
ELASTIC_CLOUD_ID=your-cloud-id-here
ELASTIC_API_KEY=your-api-key-here
KIBANA_URL=https://your-deployment.kb.us-east-1.aws.elastic.cloud
```

---

## Demo scenarios

| Scenario | Service | Pattern | Root cause |
|---|---|---|---|
| Memory Leak | payment-service | Memory 55% → 89% over 25 min | JVM connection pool not releasing memory |
| Deployment Rollback | checkout-service | Error rate 0.4 → 18/min after deploy | NPE in cart serialisation in v3.5.0 |
| Error Spike | auth-service | Error rate 0.3 → 28/min instantly | Redis session cache went offline |

---

## Hackathon context

**Event:** Elasticsearch Agent Builder Hackathon
**Dates:** January 22 – February 27, 2026
**Prize pool:** $20,000
**Judging criteria:** Multi-step reasoning, tool orchestration, real-world automation, measurable impact

QuantumState targets the **time-series anomaly detection** and **multi-agent** tracks with a concrete, measurable outcome: MTTR reduced from ~47 minutes to ~4 minutes.
